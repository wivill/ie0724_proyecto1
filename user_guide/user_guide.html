

<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Guía de usuario para el AVL Tree &mdash; documentación de AVLtree - 1.0.0</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Complejidad temporal del AVL tree" href="../complexity/complexity.html" />
    <link rel="prev" title="Documentación AVLtree" href="../index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> AVLtree
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Documentación AVLtree</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Guía de usuario para el AVL Tree</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#compilacion-de-estructura-de-datos">Compilación de estructura de datos</a></li>
<li class="toctree-l2"><a class="reference internal" href="#estructura-de-datos-para-un-nodo-del-avl-tree">Estructura de datos para un nodo del AVL Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pruebas-y-casos-de-uso">Pruebas y casos de uso</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creacion-del-avl-tree">Creación del AVL tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#agregar-un-nuevo-nodo-al-avl-tree">Agregar un nuevo nodo al AVL tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buscar-un-nodo-en-el-avl-tree">Buscar un nodo en el AVL tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remover-un-nodo-del-avl-tree">Remover un nodo del AVL tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maximo-y-minimo-nodo-del-avl-tree">Máximo y mínimo nodo del AVL tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#imprimir-un-nodo-o-todo-el-avl-tree">Imprimir un nodo o todo el AVL tree</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complexity/complexity.html">Complejidad temporal del AVL tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AVLtree</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Guía de usuario para el AVL Tree</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_guide/user_guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="guia-de-usuario-para-el-avl-tree">
<span id="avltree-user-guide-guia"></span><h1>Guía de usuario para el AVL Tree<a class="headerlink" href="#guia-de-usuario-para-el-avl-tree" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En esta sección se detalla la forma básica de usar la estructura de datos AVL Tree
implementada. Para poder ver el código directamente se puede clonar del <a class="reference external" href="https://github.com/wivill/ie0724_proyecto1">repositorio</a>
en Github:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git clone https://github.com/wivill/ie0724_proyecto1.git #En caso de no tener usuario en Github.</span>
<span class="go">git clone git@github.com:wivill/ie0724_proyecto1.git #Si tiene usuario y llave SSH.</span>
</pre></div>
</div>
<p>Al posicionarnos en el directorio principal del repositorio que contiene la estructura
de datos, nos encontramos con la siguiente estructura de directorios:</p>
<ul class="simple">
<li><p><strong>debug</strong>: Este es un directorio para depuración.</p></li>
<li><p><strong>doc</strong>: Acá se tienen los archivos fuente para esta documentación.</p></li>
<li><p><strong>docs_doxygen</strong>: Documentación legacy generada mediante Doxygen de la estructura de datos.</p></li>
<li><p><strong>include</strong>: Acá se encuentran los header files de la estructura de datos.</p></li>
<li><p><strong>src</strong>: Acá está el código fuente propiamente del AVL Tree.</p></li>
<li><p><strong>test</strong>: Acá está el código fuente para el banco de pruebas de la estructura de datos.</p></li>
</ul>
<p>Adicionalmente se tienen los siguientes archivos:</p>
<ul class="simple">
<li><p><strong>CMakeLists.txt</strong>: Contiene las directivas para poder compilar la estructura de datos, pruebas y documentación usando CMake.</p></li>
<li><p><strong>Dockerfile</strong>: Receta de Docker para ejecutar pruebas sobre la estructura de datos en un workflow de Github.</p></li>
<li><p><strong>docker-compose.test.yml</strong>: Receta de Docker Compose para facilitar la creación de contenedores usando Dockerfiles como base.</p></li>
<li><p><strong>LICENSE</strong>: Licencia GPL3 incluída en el repositorio.</p></li>
<li><p><strong>Makefile</strong>: Receta para compilación de la estructura. Se pueden encontrar más detalles en la sección <a class="reference internal" href="#compilacion-de-estructura-de-datos">Compilación de estructura de datos</a></p></li>
<li><p><strong>README.md</strong>: Incluye una pequeña descripción del proyecto, los autores, y enlaces a esta documentación y al repositorio en Github.</p></li>
</ul>
<div class="section" id="compilacion-de-estructura-de-datos">
<span id="avltree-user-guide-compilacion"></span><h2>Compilación de estructura de datos<a class="headerlink" href="#compilacion-de-estructura-de-datos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para poder compilar estructura de datos, correr el banco de pruebas o generar la documentación
manualmente se emplea el Makefile ubicado en la raíz del repositorio. Este Makefile contiene las
siguientes opciones:</p>
<ul class="simple">
<li><p><strong>default</strong>: al llamar simplemente a make se genera el directorio build y el Makefile con CMake.</p></li>
<li><p><strong>build</strong>: Genera los ejecutables en build luego de generar el Makefile.</p></li>
<li><p><strong>check</strong>: Compila la estructura de datos y el banco de pruebas, luego lo ejecuta para ejercitar los métodos de la estructura de datos.</p></li>
<li><p><strong>clean</strong>: Elimina el directorio build junto con sus contenidos.</p></li>
<li><p><strong>docs</strong>: Genera manualmente la documentación del proyecto usando sphinx. El html resultante se encuentra en doc/_build/html.</p></li>
</ul>
<p>En cada caso el uso del Makefile es bastante sencillo de acuerdo con la explicación anterior.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">make</span>
<span class="go">make build</span>
<span class="go">make check</span>
<span class="go">make docs</span>
<span class="go">make clean</span>
</pre></div>
</div>
<p>En este caso nos concierne particularmente el uso de make build y make check para compilar y probar
la estructura de datos.</p>
</div>
<div class="section" id="estructura-de-datos-para-un-nodo-del-avl-tree">
<span id="avltree-user-guide-struct"></span><h2>Estructura de datos para un nodo del AVL Tree<a class="headerlink" href="#estructura-de-datos-para-un-nodo-del-avl-tree" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La definición del nodo para esta implementación se hace mediante un struct, tal y como
se muestra en el bloque de código:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">avl_node</span> <span class="p">{</span>
    <span class="cm">/* Puntero al nodo padre */</span>
    <span class="k">struct</span> <span class="nc">avl_node</span> <span class="o">*</span><span class="n">pc_node</span><span class="p">;</span>

    <span class="cm">/** Puntero al nodo hijo izquierdo */</span>
    <span class="k">struct</span> <span class="nc">avl_node</span> <span class="o">*</span><span class="n">lc_node</span><span class="p">;</span>

    <span class="cm">/** Puntero al nodo hijo derecho */</span>
    <span class="k">struct</span> <span class="nc">avl_node</span> <span class="o">*</span><span class="n">rc_node</span><span class="p">;</span>

    <span class="cm">/** Número flotante asociado al nodo */</span>
    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>

    <span class="cm">/* Altura */</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Tal y como se puede apreciar, cada nodo contiene información referente a su relación con otros
nodos a través de los punteros al nodo padre, nodos hijos izquierdo y derecho, el valor asociado
a dicho nodo y que se usa como criterio para saber su ubicación en el árbol, y la altura que se
usa como criterio para balancear el árbol.</p>
</div>
<div class="section" id="pruebas-y-casos-de-uso">
<span id="avltree-user-guide-pruebas"></span><h2>Pruebas y casos de uso<a class="headerlink" href="#pruebas-y-casos-de-uso" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Basándonos en las pruebas unitarias en el archivo test/main_test.cpp, se presentan
algunos casos de uso típicos para inicializar el AVL tree, buscar, agregar y eliminar
nodos, entre otros posibles ejercicios para el uso de la estructura de datos. La mayoría
de los métodos retorna una bandera que se usa para evaluar si fue exitoso o no, por lo que
si se requiere una salida distinta se debe pasar como argumento de entrada y modificarlo
dentro del método.</p>
<p>Los códigos que retornan típicamente las funciones del AVL tree son:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">avl_error_codes</span> <span class="p">{</span>
    <span class="n">AVL_SUCCESS</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">AVL_INVALID_PARAM</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">,</span>
    <span class="n">AVL_OUT_OF_RANGE</span>  <span class="o">=</span> <span class="mi">-2</span><span class="p">,</span>
    <span class="n">AVL_TIMEOUT</span>       <span class="o">=</span> <span class="mi">-3</span><span class="p">,</span>
    <span class="n">AVL_NOT_FOUND</span>     <span class="o">=</span> <span class="mi">-4</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="creacion-del-avl-tree">
<h3>Creación del AVL tree<a class="headerlink" href="#creacion-del-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El siguiente bloque de código muestra cómo se genera una lista con valores tipo float
los cuales se emplean como llaves para cada nodo del árbol a construir. El árbol es creado
llamando al método avl_create que recibe como argumentos la lista y una estructura node con
su valor asociado y altura inicializada en 1.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;avltree.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Creación de lista con elementos a agregar al árbol</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">listaGanadora</span><span class="p">;</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">18.5</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">13.99</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">2.5</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">16.0</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">55.2</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">42.69</span><span class="p">);</span>
    <span class="n">listaGanadora</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>

    <span class="c1">// Estructura base que será inicialmente la raíz del árbol</span>
    <span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">arbol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">avl_node</span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>

    <span class="c1">// Método para crear el árbol a partir de la lista y la raíz inicial</span>
    <span class="n">avl_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listaGanadora</span><span class="p">,</span> <span class="n">arbol</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="agregar-un-nuevo-nodo-al-avl-tree">
<h3>Agregar un nuevo nodo al AVL tree<a class="headerlink" href="#agregar-un-nuevo-nodo-al-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El proceso para agregar un nodo nuevo una vez creado el árbol se hace llamando al método
avl_node_add, al cual se le debe pasar como argumento la raiz del árbol, una estructura node
con el valor del nuevo nodo a agregar y un struct que corresponde a la nueva raíz. Este puede
ir vacío pues se usará como recipiente para la nueva raíz a la hora de autobalancear el árbol.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Crea estructura a partir de un nodo base y una lista</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">arbol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">avl_node</span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">avl_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listaGanadora</span><span class="p">,</span> <span class="n">arbol</span><span class="p">);</span>

<span class="c1">// Crea un nodo nuevo a agregar y un struct para la nueva raíz en caso de ser necesario</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">nuevo_nodo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">avl_node</span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">14</span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">nueva_raiz</span><span class="p">;</span>
<span class="n">avl_node_add</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="n">nuevo_nodo</span><span class="p">,</span> <span class="n">nueva_raiz</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="buscar-un-nodo-en-el-avl-tree">
<h3>Buscar un nodo en el AVL tree<a class="headerlink" href="#buscar-un-nodo-en-el-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El proceso de búsqueda de un nodo particular se realiza mediante la función avl_search, el cual
recibe como argumentos la raíz del árbol, el valor del nodo a buscar, y la dirección a un struct
en el cual se almacena el nodo encontrado. El método retorna una confirmación de si encontró el
nodo o no.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Valor a buscar en el árbol</span>
<span class="kt">float</span> <span class="n">valor_busqueda</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

<span class="c1">// Estructura que contendrá el nodo resultado de la búsqueda</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">busq</span><span class="p">;</span>

<span class="c1">// Busca el nodo y evalúa si existe en el árbol o no.</span>
<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">avl_search</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="n">valor_busqueda</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busq</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AVL_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Encontré el nodo &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">valor_busqueda</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AVL_NOT_FOUND</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No encontré el nodo &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">valor_busqueda</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="remover-un-nodo-del-avl-tree">
<h3>Remover un nodo del AVL tree<a class="headerlink" href="#remover-un-nodo-del-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>De forma complementaria al proceso para agregar un nodo, para remover uno primero debemos
buscarlo en la estructura, y este resultado se usa como argumento para llamar al método
avl_node_remove.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Valor a buscar en el árbol</span>
<span class="kt">float</span> <span class="n">valor_busqueda</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

<span class="c1">// Estructura que contendrá el nodo resultado de la búsqueda</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">busq</span><span class="p">;</span>

<span class="c1">// Estructura que contendrá la nueva raíz</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">nueva_raiz</span><span class="p">;</span>

<span class="c1">// Busca el nodo y evalúa si existe en el árbol o no.</span>
<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">avl_search</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="n">valor_busqueda</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busq</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AVL_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Encontré el nodo &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">valor_busqueda</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Remueve el nodo del árbol</span>
    <span class="n">avl_node_remove</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="n">busq</span><span class="p">,</span> <span class="n">nueva_raiz</span><span class="p">);</span>

<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AVL_NOT_FOUND</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No encontré el nodo &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">valor_busqueda</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="maximo-y-minimo-nodo-del-avl-tree">
<h3>Máximo y mínimo nodo del AVL tree<a class="headerlink" href="#maximo-y-minimo-nodo-del-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>De forma similar al método avl_search, se requiere de una estructura nodo que almacene
el resultado en caso de ser exitoso. El método para obtener el nodo de máximo valor es
avl_max_get y para el mínimo se denomina avl_min_get. Ambos reciben como argumentos la raíz del árbol y la dirección a un struct
en el cual se almacena el nodo encontrado.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Estructura que contendrá el nodo resultado de la búsqueda</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">max_busq</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">min_busq</span><span class="p">;</span>

<span class="c1">// Busca el nodo máximo y minimo</span>
<span class="n">avl_max_get</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_busq</span><span class="p">);</span>
<span class="n">avl_min_get</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_busq</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="imprimir-un-nodo-o-todo-el-avl-tree">
<h3>Imprimir un nodo o todo el AVL tree<a class="headerlink" href="#imprimir-un-nodo-o-todo-el-avl-tree" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El método avl_print puede usarse para obtener una validación visual de los métodos de búsqueda
de nodos presentados hasta ahora, así como para visualizar el árbol completo en la terminal. Este
método recibe como argumento únicamente un nodo el cual puede ser la raíz del árbol o un nodo
resultado.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Valor a buscar en el árbol</span>
<span class="kt">float</span> <span class="n">valor_busqueda</span> <span class="o">=</span> <span class="mf">42.69</span><span class="p">;</span>

<span class="c1">// Estructura que contendrá el nodo resultado de la búsqueda</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">max_busq</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">min_busq</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">avl_node</span><span class="o">*</span> <span class="n">busq</span><span class="p">;</span>

<span class="c1">// Busca el nodo máximo y minimo</span>
<span class="n">avl_max_get</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_busq</span><span class="p">);</span>
<span class="n">avl_min_get</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_busq</span><span class="p">);</span>
<span class="n">avl_search</span><span class="p">(</span><span class="n">arbol</span><span class="p">,</span> <span class="n">valor_busqueda</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busq</span><span class="p">);</span>

<span class="c1">// Imprime el árbol y los resultados</span>
<span class="n">avl_print</span><span class="p">(</span><span class="n">arbol</span><span class="p">)</span>
<span class="n">avl_print</span><span class="p">(</span><span class="n">max_busq</span><span class="p">)</span>
<span class="n">avl_print</span><span class="p">(</span><span class="n">min_busq</span><span class="p">)</span>
<span class="n">avl_print</span><span class="p">(</span><span class="n">busq</span><span class="p">)</span>
</pre></div>
</div>
<p>Los resultados se ven de forma similar al siguiente bloque:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> Árbol
<span class="go">└──11</span>
<span class="go">    ├──0.5</span>
<span class="go">    │   └──2.5</span>
<span class="go">    └──42.69</span>
<span class="go">        ├──16</span>
<span class="go">        └──55.2</span>

<span class="gp">#</span> Máximo
<span class="go">└──55.2</span>

<span class="gp">#</span> Mínimo
<span class="go">└──0.5</span>

<span class="gp">#</span> Nodo buscado
<span class="go">└──42.69</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../complexity/complexity.html" class="btn btn-neutral float-right" title="Complejidad temporal del AVL tree" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../index.html" class="btn btn-neutral float-left" title="Documentación AVLtree" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Mariela Hernandez, Jose Lopez, Willy Villalobos, Bernardo Zuñiga

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>